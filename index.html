<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Activities Toggle Checklist</title>
<style>
:root {
  --bg1: #12001f;
  --bg2: #001a33;
  --card: rgba(18, 8, 40, 0.55);
  --border: rgba(255,255,255,0.14);
  --text: rgba(255,255,255,0.92);
  --muted: rgba(255,255,255,0.72);
  --glow1: #ff5cf4;
  --glow2: #42f5ff;
  --glow3: #ffd36b;
  --pill: rgba(255,255,255,0.06);
}

* { box-sizing: border-box; }

body {
  margin: 0;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji","Segoe UI Emoji";
  color: var(--text);
  background:
    radial-gradient(1100px 700px at 20% 10%, rgba(255,92,244,0.22), transparent 55%),
    radial-gradient(900px 600px at 85% 25%, rgba(66,245,255,0.18), transparent 55%),
    radial-gradient(900px 650px at 50% 90%, rgba(255,211,107,0.12), transparent 60%),
    linear-gradient(160deg, var(--bg1), var(--bg2));
  min-height: 100vh;
}

header {
  padding: 22px 18px 12px;
  max-width: 1200px;
  margin: 0 auto;
}

h1 {
  margin: 0 0 6px 0;
  font-weight: 800;
  letter-spacing: 0.4px;
  text-shadow: 0 0 22px rgba(255,92,244,0.25), 0 0 28px rgba(66,245,255,0.18);
}

.sub {
  color: var(--muted);
  margin: 0 0 14px 0;
}

.toolbar {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  align-items: center;
  padding: 12px;
  border: 1px solid var(--border);
  background: var(--card);
  border-radius: 14px;
  backdrop-filter: blur(10px);
  box-shadow: 0 14px 40px rgba(0,0,0,0.25);

  position: sticky;
  top: 14px;
  z-index: 50;
}

#q {
  flex: 1 1 320px;
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 12px 12px;
  background: rgba(0,0,0,0.18);
  color: var(--text);
  outline: none;
}
#q:focus {
  border-color: rgba(66,245,255,0.55);
  box-shadow: 0 0 0 3px rgba(66,245,255,0.18);
}

.btn {
  border: 1px solid var(--border);
  background: rgba(0,0,0,0.18);
  color: var(--text);
  border-radius: 12px;
  padding: 10px 12px;
  cursor: pointer;
  transition: transform 0.05s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  user-select: none;
}
.btn:hover {
  border-color: rgba(255,92,244,0.55);
  box-shadow: 0 0 0 3px rgba(255,92,244,0.14);
}
.btn:active {
  transform: translateY(1px);
}

/* Copy button: bigger, squarer, redder */
.btn.btnCopy {
  font-size: 1.05rem;
  font-weight: 800;
  padding: 12px 16px;
  min-width: 180px;
  border-radius: 10px; /* rounded-square */
  border-color: rgba(255, 90, 110, 0.78);
  background: linear-gradient(135deg, rgba(255, 45, 85, 0.66), rgba(255, 92, 244, 0.18));
  box-shadow: 0 12px 26px rgba(255, 45, 85, 0.22), 0 0 0 1px rgba(255,255,255,0.03) inset;
}
.btn.btnCopy:hover {
  border-color: rgba(255, 140, 155, 0.88);
  box-shadow: 0 16px 34px rgba(255, 45, 85, 0.30), 0 0 0 1px rgba(255,255,255,0.05) inset;
  transform: translateY(-1px);
}
.btn.btnCopy:active {
  transform: translateY(0px) scale(0.99);
}

main {
  max-width: 1200px;
  margin: 10px auto 28px;
  padding: 0 18px 24px;
}

details {
  border: 1px solid var(--border);
  background: var(--card);
  border-radius: 14px;
  backdrop-filter: blur(10px);
  margin: 10px 0;
  overflow: hidden;
}

summary {
  list-style: none;
  cursor: pointer;
  padding: 14px 14px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  user-select: none;
}
summary::-webkit-details-marker { display:none; }

.summaryLeft {
  display: flex;
  gap: 10px;
  align-items: baseline;
}
.sectionTitle {
  font-weight: 800;
  letter-spacing: 0.3px;
}
.sectionMeta {
  color: var(--muted);
  font-size: 0.92rem;
}

.pills {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  padding: 14px 14px 16px;
  border-top: 1px solid rgba(255,255,255,0.08);
}



.bottomNav {
  display: flex;
  justify-content: center;
  gap: 14px;
  padding: 16px 14px 18px;
  border-top: 1px solid rgba(255,255,255,0.08);
}
.bottomNav .btnNav {
  /* keep existing .btnNav sizing */
}

.pill {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 10px 12px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.14);
  background: rgba(255,255,255,0.06);
  color: var(--text);
  cursor: pointer;
  user-select: none;
  transition: transform 0.05s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  font-size: 0.95rem;
  line-height: 1.1;
}
.pill:hover {
  border-color: rgba(66,245,255,0.55);
  box-shadow: 0 0 0 3px rgba(66,245,255,0.12);
}
.pill[aria-pressed="true"] {
  background: linear-gradient(
    135deg,
    hsla(var(--h, 300), 95%, 65%, 0.30),
    hsla(var(--h2, 190), 95%, 65%, 0.18)
  );
  border-color: hsla(var(--h, 300), 95%, 75%, 0.78);
  box-shadow:
    0 0 0 3px hsla(var(--h, 300), 95%, 65%, 0.14),
    0 0 28px hsla(var(--h2, 190), 95%, 65%, 0.16);
}
.pill:active {
  transform: translateY(1px);
}

footer {
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 18px 24px;
  color: var(--muted);
  font-size: 0.92rem;
}
.toast {
  position: fixed;
  left: 50%;
  bottom: 18px;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.55);
  border: 1px solid rgba(255,255,255,0.18);
  padding: 10px 12px;
  border-radius: 999px;
  backdrop-filter: blur(10px);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.2s ease;
}
.toast.show { opacity: 1; }


/* --- Vaporwave hero + audio toggles --- */
#heroWrap {
  max-width: 1100px;
  margin: 18px auto 6px;
  padding: 0 18px;
}

.heroCard {
  position: relative;
  border-radius: 18px;
  padding: 14px 14px 12px;
  background: linear-gradient(135deg, rgba(255,0,200,0.14), rgba(0,255,255,0.10));
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow: 0 10px 30px rgba(0,0,0,0.28);
  overflow: hidden;
}

.heroTitle {
  font-weight: 800;
  letter-spacing: 0.18em;
  text-transform: lowercase;
  margin: 2px 2px 10px;
  opacity: 0.95;
  white-space: pre;
}

.heroVidFrame {
  position: relative;
  height: 240px;
  border-radius: 16px;
  overflow: hidden;
  background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.12), rgba(0,0,0,0.55));
  border: 1px solid rgba(255,255,255,0.12);
  transform-style: preserve-3d;
  perspective: 700px;
  animation: heroTilt 7.5s ease-in-out infinite;
}

@keyframes heroTilt {
  0%, 100% { transform: rotateY(-10deg) rotateX(2deg); }
  50%      { transform: rotateY(10deg) rotateX(-2deg); }
}

#davidVid {
  width: 100%;
  height: 100%;
  object-fit: cover;
  filter: saturate(1.25) contrast(1.08) hue-rotate(12deg);
  transform: scale(1.03);
}

.heroOverlay {
  pointer-events: none;
  position: absolute;
  inset: 0;
  background:
    repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,0.06) 0px,
      rgba(255,255,255,0.06) 1px,
      rgba(0,0,0,0) 3px,
      rgba(0,0,0,0) 5px
    ),
    radial-gradient(circle at 70% 20%, rgba(255,0,200,0.18), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 20% 80%, rgba(0,255,255,0.18), rgba(0,0,0,0) 60%);
  mix-blend-mode: screen;
  opacity: 0.85;
}

.heroFallback {
  position: absolute;
  inset: 0;
  display: grid;
  place-items: center;
  padding: 16px;
  text-align: center;
  background: rgba(0,0,0,0.35);
  backdrop-filter: blur(4px);
  color: rgba(255,255,255,0.92);
}

.heroFallback code {
  padding: 2px 6px;
  border-radius: 8px;
  background: rgba(0,0,0,0.35);
  border: 1px solid rgba(255,255,255,0.14);
}

.heroSub {
  margin-top: 10px;
  font-size: 0.92rem;
  opacity: 0.90;
}

/* Audio toggle buttons: intentionally "not like the others" */
.btn.btnAudio {
  border: 1px solid rgba(255,255,255,0.16);
  box-shadow: 0 6px 18px rgba(0,0,0,0.22);
}

.btn.btnSfx {
  background: linear-gradient(135deg, rgba(0,255,170,0.22), rgba(0,255,255,0.12));
}

.btn.btnMusic {
  background: linear-gradient(135deg, rgba(255,0,200,0.20), rgba(255,200,0,0.10));
}

.btn.btnAudio[aria-pressed="false"] {
  opacity: 0.72;
  filter: saturate(0.85);
}


/* --- Guided section stepper --- */
.stepperNote {
  color: var(--muted);
  font-size: 0.92rem;
  margin-left: 2px;
}

.btn.btnStep {
  border: 1px solid rgba(255,255,255,0.16);
  background: linear-gradient(135deg, rgba(66,245,255,0.10), rgba(255,92,244,0.10));
}
.btnNav {
  /* Bigger, friendlier "stepper" controls */
  font-size: 1.06rem;
  font-weight: 700;
  padding: 12px 18px;
  min-width: 128px;
  border-color: rgba(255, 90, 110, 0.78);
  background: linear-gradient(135deg, rgba(255, 60, 90, 0.58), rgba(255, 92, 244, 0.14));
  box-shadow: 0 10px 22px rgba(255, 60, 90, 0.22), 0 0 0 1px rgba(255,255,255,0.03) inset;
}

.btnNav:hover {
  border-color: rgba(255, 130, 150, 0.88);
  box-shadow: 0 14px 30px rgba(255, 60, 90, 0.30), 0 0 0 1px rgba(255,255,255,0.05) inset;
  transform: translateY(-1px);
}

.btnNav:active {
  transform: translateY(0px) scale(0.99);
}

.btnNav:focus-visible {
  outline: 2px solid rgba(255, 180, 180, 0.80);
  outline-offset: 2px;
}

@media (max-width: 640px) {
  .btnNav {
    min-width: 110px;
    padding: 12px 14px;
  }
}


.btn.btnMode {
  font-size: 1.06rem;
  font-weight: 800;
  padding: 12px 18px;
  min-width: 150px;
  border-color: rgba(66,245,255,0.55);
  background: linear-gradient(135deg, rgba(40,120,255,0.36), rgba(66,245,255,0.18));
  box-shadow: 0 10px 22px rgba(40,120,255,0.18), 0 0 0 1px rgba(255,255,255,0.03) inset;
}
#modeToggleBtn[aria-pressed="false"] {
  background: linear-gradient(135deg, rgba(40,120,255,0.26), rgba(0,0,0,0.18));
  border-color: rgba(66,245,255,0.32);
}

.btn[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
  filter: saturate(0.8);
}

/* In guided mode, "expand/collapse all" isn't very meaningful */
body[data-guided="true"] #expandBtn,
body[data-guided="true"] #collapseBtn {
  display: none;
}

</style>
</head>
<body>
<header>
  <h1>Select the Activities that Bring You Joy</h1>
  <p class="sub">Click to toggle. Search to filter. Sections are collapsible. Your selections autosave on this device. Copy exports selected items comma-separated.</p>

  <div class="toolbar">
    <button class="btn btnStep btnMode" id="modeToggleBtn" type="button" aria-pressed="true" title="Guided mode: move through sections one-by-one">Guided: On</button>
    <button class="btn btnStep btnNav" id="prevSegBtn" type="button" title="Previous section">◀ Previous</button>
    <button class="btn btnStep btnNav" id="nextSegBtn" type="button" title="Next section">Next ▶</button>
    <span id="segLabel" class="sectionMeta"></span>
    <input id="q" type="search" placeholder="Search (e.g., breathe, cook, program)" autocomplete="off">
    
    <button class="btn btnCopy" id="copyBtn" type="button">Click here to Copy</button>
    <button class="btn" id="clearBtn" type="button">Clear all</button>
    <button class="btn" id="expandBtn" type="button">Expand all</button>
    <button class="btn" id="collapseBtn" type="button">Collapse all</button>
        
    
    
    
    <button class="btn btnAudio btnSfx" id="sfxToggleBtn" type="button" aria-pressed="true" title="Toggle Sound FX">Sound FX: On</button>
    <button class="btn btnAudio btnMusic" id="musicToggleBtn" type="button" aria-pressed="false" title="Toggle synthwave background">Music: Off</button>
    <span id="count" class="sectionMeta"></span>
  </div>
</header>

<main id="app"></main>

<div id="heroWrap">
  <div class="heroCard" aria-label="Vaporwave intro">
    <div class="heroTitle">N o x ' s   A c t i v i t y   S e l e c t o r</div>
    <div class="heroVidFrame">
      <video id="davidVid" autoplay loop muted playsinline preload="metadata">
        <source src="david_vaporwave.mp4" type="video/mp4">
      </video>
      <div class="heroOverlay" aria-hidden="true"></div>
      <div class="heroFallback" id="heroFallback">
        Drop a <code>david_vaporwave.mp4</code> file next to this HTML to see the rotating David head here.
      </div>
    </div>
    <div class="heroSub">Synthwave is off by default • Sound FX is on by default</div>
  </div>
</div>


<footer>
  Created by Nox Famous December 16th 2025 with the help of [Contributors: Slizer & Brenda Billings].
</footer>

<div class="toast" id="toast">Copied.</div>

<audio id="bgMusic" src="synthwave_loop.wav" loop preload="auto"></audio>


<script>

// --- Audio state (sound fx + synthwave) ---
let sfxEnabled = true;   // sound fx is ON by default
let musicEnabled = false; // music is OFF by default
const LS_SFX = "vap_sfx_on";
const LS_MUSIC = "vap_music_on";

// Keep the viewport steady: no surprise jumps (only the user scrolls).
function keepScrollStable(fn) {
  const x = window.pageXOffset || 0;
  const y = window.pageYOffset || 0;
  fn();
  // Two RAFs to beat layout + focus scroll in most browsers.
  requestAnimationFrame(() => {
    window.scrollTo(x, y);
    requestAnimationFrame(() => window.scrollTo(x, y));
  });
}


const ITEMS = ['breathing','blinking','swallowing','chewing','stretching','yawning','standing','sitting','walking','running','jogging','jumping','crawling','balancing','bending','lifting','carrying','pulling','pushing','climbing','falling asleep','waking up','sneezing','coughing','sweating','shivering','napping','sleeping','warming up','cooling down','drinking','eating','tasting','sniffing','touching','hearing','seeing','smelling','speaking','whispering','humming','singing','laughing','crying','smiling','frowning','sighing','groaning','daydreaming','thinking','cooking','boiling water','frying food','baking','washing dishes','vacuuming','sweeping','mopping','folding clothes','doing laundry','ironing','cleaning windows','making the bed','showering','brushing teeth','shaving','combing hair','applying lotion','getting dressed','undressing','grocery shopping','refilling prescriptions','paying bills','budgeting','taking out the trash','recycling','opening mail','organizing drawers','writing lists','meal prepping','packing bags','unpacking','calling someone','texting','sending emails','waiting in line','commuting','checking the weather','reading instructions','setting reminders','locking doors','charging devices','making coffee','making tea','watering plants','feeding pets','taking medication','using the bathroom','washing hands','tidying up','listening','empathizing','consoling someone','encouraging someone','complimenting','apologizing','forgiving','debating','arguing','negotiating','mediating','comforting someone','reflecting on feelings','journaling emotions','setting boundaries','giving advice','asking questions','telling stories','meeting new people','introducing yourself','attending a party','hosting guests','networking','hugging','handshaking','high-fiving','waving','nodding','making eye contact','avoiding eye contact','confessing something','comfort eating','venting','cry-laughing','feeling nostalgia','feeling anxiety','feeling joy','feeling frustration','feeling excitement','feeling curiosity','caring for others','caring for yourself','practicing gratitude','setting goals','daydreaming about the future','reminiscing','missing someone','letting go','sharing secrets','keeping secrets','reading','writing','editing','brainstorming','proofreading','memorizing','solving puzzles','analyzing data','calculating','strategizing','planning','organizing','designing','drawing','sketching','painting','sculpting','crafting','knitting','crocheting','sewing','quilting','woodworking','pottery','photography','filming','video editing','sound recording','mixing audio','playing music','improvising','composing','acting','dancing','choreographing','storyboarding','illustrating','calligraphy','graphic design','making memes','collaging','worldbuilding','writing poetry','writing fiction','solving riddles','strategizing games','making playlists','mapping routes','inventing things','hiking','biking','swimming','surfing','kayaking','canoeing','sailing','paddleboarding','trail running','rock climbing','bouldering','skateboarding','rollerblading','ice skating','skiing','snowboarding','snowshoeing','sledding','fishing','hunting','gardening','planting trees','mowing the lawn','weeding','composting','feeding wildlife','birdwatching','stargazing','camping','building a campfire','pitching a tent','orienteering','foraging','mushroom hunting','chopping wood','jogging with a dog','throwing a frisbee','playing catch','yoga','pilates','weightlifting','boxing','kickboxing','stretching routines','aerobics','martial arts','tai chi','qi gong','fencing','archery','horseback riding','barrel racing','vaulting','mountain hiking','trail clearing','parkour','jump roping','trampoline jumping','rowing','scuba diving','snorkeling','spearfishing','cliff jumping','paragliding','skydiving','ziplining','uphill biking','downhill biking','inline skating','cross-country skiing','sprinting','playing soccer','playing basketball','playing volleyball','playing tennis','playing badminton','table tennis','wrestling','swimming laps','diving','water polo','long jumping','high jumping','javelin throwing','hammer throw','shot put','gymnastics','cheerleading','tumbling','baton twirling','handstands','cartwheeling','unicycling','balance beam practice','slacklining','running errands','walking a dog','exploring parks','watching sunsets','browsing the internet','watching YouTube','streaming shows','doomscrolling','online shopping','scrolling social media','posting photos','commenting','liking posts','sharing content','messaging friends','video calling','voice chatting','gaming','speedrunning','modding games','streaming on Twitch','editing VODs','coding','programming','debugging','writing scripts','designing websites','UI/UX design','building apps','learning languages online','taking digital notes','using spreadsheets','managing calendars','file organizing','running virtual meetings','using AI tools','typing','copy-pasting','dragging files','installing software','updating drivers','troubleshooting tech','building PCs','backing up data','creating presentations','graphic editing','photo retouching','3D modeling','Blender sculpting','creating animations','writing code snippets','creating bots','API testing','cybersecurity practice','ethical hacking','data entry','data analysis','spreadsheet modeling','managing digital finances','using crypto wallets','VR gaming','AR experiences','drone flying','making digital art','editing sprite sheets','creating GIFs','using filters','coding neural networks','training ML models','animating sprites','writing fanfic','curating Pinterest boards','designing wallpapers','blogging','vlogging','creating tutorials','recording podcasts','scheduling posts','writing newsletters','troubleshooting Wi-Fi','updating firmware','creating databases','tagging metadata','using digital to-do lists','playing online chess','solving captchas','saving bookmarks','password managing','pixel art creation','using Discord','managing servers','moderating communities','setting server roles','creating channels','uploading emojis','building Notion dashboards','automating workflows','meditating','deep breathing','grounding exercises','mindfulness practice','mantra chanting','self-soothing','emotional regulation','identifying triggers','unpacking memories','visualizing success','reframing thoughts','body scanning','progressive muscle relaxation','shadow work','affirmations','seeking comfort','asking for help','therapy homework','introspection','goal tracking','building routines','habit stacking','reflecting on choices','reading self-help','journaling insights','writing affirmations','spending time alone','reconnecting with others','healing old wounds','forgiving yourself','practicing stillness','taking breaks','crying intentionally','understanding emotions','naming feelings','resting','napping intentionally','regulating stress','walking to think','pacing','dissociating','grounding in nature','cleansing your space','rearranging furniture','taking long showers','listening to calming music','singing in the shower','dancing alone','stretching in the morning','stimming','sensory seeking','sensory avoidance','aromatherapy','lighting candles','tidying your desk','drinking cold water','drinking warm tea','hugging a pillow','watching comfort shows','wearing soft clothes','petting animals','feeding birds','helping a friend','talking through problems','venting safely','asking clarifying questions','researching solutions','making decisions','delaying decisions','prioritizing tasks','saying no','saying yes','compromising','self-advocating','setting boundaries','maintaining boundaries','repairing relationships','ending relationships','grieving','celebrating','feeling pride','feeling relief','feeling anticipation','feeling uncertainty','working','commuting','replying to emails','attending meetings','brainstorming with coworkers','presenting ideas','taking notes','leading teams','collaborating','negotiating contracts','onboarding','training others','fixing equipment','restocking supplies','organizing inventory','project planning','scheduling tasks','time management','delegating','filing documents','archiving','reading reports','writing reports','troubleshooting systems','learning new skills','mentoring others','reviewing work','quality control','manufacturing tasks','customer service','answering phones','greeting clients','processing orders','transporting goods','driving cars','riding buses','cycling to work','navigating maps','booking appointments','managing finances','balancing accounts','calculating taxes','signing papers','reading legal documents','researching laws','contacting support','renewing licenses','studying','taking tests','attending classes','listening to lectures','writing essays','reading textbooks','highlighting notes','group study','memorization drills','practicing skills','prepping presentations','learning instruments','rehearsing music','conducting experiments','observing results','writing hypotheses','designing posters','participating in labs','attending workshops','joining clubs','tutoring','volunteering','donating items','participating in charity events','mentoring youth','community organizing','activism','advocacy','protesting','voting','writing petitions','speaking publicly','debating ideas','educating others','raising awareness','fundraising','building community projects','stretching before exercise','cooling down after workouts','taking vitamins','applying sunscreen','moisturizing','trimming nails','clipping toenails','brushing hair','conditioning hair','exfoliating skin','shaving body hair','shaving beard','brushing teeth','flossing','mouthwash rinsing','applying deodorant','massaging muscles','self-checking vitals','first aid','treating cuts','bandaging wounds','using ice packs','heating pads','stretching injured muscles','physical therapy exercises','med tracking','taking prescriptions','scheduling appointments','attending medical checkups','attending therapy','researching symptoms','doing breathwork','resting in bed','lowering stress','drinking electrolytes','improving posture','stretching neck','standing breaks at desk','drinking herbal tea','meditating with apps','taking long baths','aromatherapy showers','going for health walks','cooking healthy meals','reducing sugar intake','tracking calories','measuring weight','getting massages','chiropractic visits','stretching hamstrings','stretching back','stretching shoulders','planning trips','packing luggage','unpacking luggage','booking flights','booking hotels','riding taxis','taking buses','riding subways','taking ferries','boarding planes','going through security','waiting in airports','traveling abroad','learning travel phrases','sampling foreign foods','sightseeing','hiking mountains','exploring forests','visiting lakes','visiting beaches','walking in cities','taking photos','navigating new places','collecting souvenirs','meeting locals','renting bikes','stargazing outdoors','camping under stars','exploring caves','swimming in rivers','visiting waterfalls','taking scenic drives','road tripping','using maps','booking tours','traveling solo','traveling with friends','navigating airports','trying local cafés','trying new cuisines','washing clothes','drying clothes','folding clothes','ironing clothes','organizing closets','sorting laundry','repairing clothes','sewing buttons','handwashing delicate fabrics','cleaning kitchen counters','scrubbing pans','disinfecting surfaces','organizing pantries','stocking food','meal planning','chopping vegetables','frying meals','roasting food','boiling pasta','making soups','baking cakes','making bread','decorating pastries','setting the table','washing floors','vacuuming carpets','scrubbing bathrooms','unclogging drains','fixing leaks','organizing cables','emptying trash bins','recycling plastics','composting food scraps','maintaining tools','painting walls','hanging shelves','assembling furniture','cleaning windows','raising blinds','lowering blinds','sweeping patios','watering gardens','trimming plants','raking leaves','shoveling snow','salting sidewalks','maintaining yard tools','maintaining appliances','changing light bulbs','changing smoke alarm batteries','organizing drawers','decluttering rooms','labeling boxes','storing seasonal items','watching movies','binge-watching shows','rewatching favorites','listening to music','discovering new artists','making playlists','attending concerts','going to festivals','watching plays','attending theatre','going to museums','going to art galleries','doing puzzles','solving sudoku','solving crosswords','reading novels','reading nonfiction','reading poetry','reading comics','collecting manga','visiting bookstores','joining book clubs','listening to podcasts','writing reviews','watching documentaries','going bowling','playing mini-golf','playing darts','playing billiards','board gaming','card gaming','tabletop RPGs','painting miniatures','cosplaying','attending conventions','karaoke','traveling for fun','trying new restaurants','visiting cafés','watching sports','participating in sports','collecting items','journaling memories','scrapbooking','making photo albums','practicing magic tricks','attending workshops','exploring hobbies','learning new recipes','doing taste tests','hiking trails','taking scenic photos','budgeting monthly expenses','tracking spending','updating spreadsheets','paying rent','paying utilities','reviewing bank statements','transferring funds','depositing checks','grocery shopping','comparing prices','coupon clipping','returning items','mailing packages','picking up parcels','renewing subscriptions','canceling subscriptions','repairing electronics','ordering supplies','replacing batteries','washing the car','refueling the car','checking tire pressure','changing oil','maintaining bicycles','fixing flat tires','booking maintenance','filling out forms','filing taxes','organizing receipts','making new friends','maintaining friendships','comforting loved ones','planning hangouts','meeting for coffee','giving gifts','receiving gifts','writing letters','sending postcards','celebrating birthdays','celebrating anniversaries','attending weddings','attending funerals','visiting family','hosting gatherings','cooking for friends','sharing meals','checking in on people','mediating conflicts','resolving misunderstandings','offering support','asking for support','learning boundaries','practicing assertiveness','giving compliments','receiving compliments','flirting','dating','introspecting about relationships','navigating heartbreak','rebuilding confidence','expressing affection','expressing gratitude','saying goodbye','saying hello','apologizing sincerely','initiating conversations','deep listening','empathizing deeply','praying','meditating in silence','lighting incense','reading sacred texts','contemplating existence','practicing gratitude','attending spiritual gatherings','connecting with nature','walking labyrinths','chanting','journaling spiritually','making altars','leaving offerings','mindful breathing','vow setting','storytelling','creating characters','worldbuilding','writing essays','writing scripts','podcast scripting','painting murals','sculpting clay','composing music','mixing music','beat making','singing in harmonies','dancing freestyle','choreographing dances','writing poetry','performing poetry','creating zines','designing posters','journaling fiction ideas','scrapbooking memories','collecting art references','photographing nature','photographing people','staging photoshoots','retouching photos','animating 2D art','animating 3D scenes','drawing digitally','pixel art design','sprite sheet creation','VFX design','storyboard creation','writing comic panels','designing outfits','costuming','prop making','observing nature','collecting samples','cataloging findings','doing science experiments','tracking weather','building simple machines','studying physics','studying chemistry','studying biology','studying astronomy','solving math problems','writing equations','modeling data','observing stars','using telescopes','collecting rocks','identifying minerals','logging field notes','reading research articles','participating in citizen science','exploring museums','stretching after sleep','reacting to news','forming opinions','changing opinions','feeling inspired','feeling discouraged','overcoming fear','procrastinating','planning future goals','sharing experiences','rewriting memories','replaying conversations','laughing at memes','sending voice notes','reacting with emojis','analyzing dreams','making wishes','evaluating risks','managing impulses','resisting temptations','indulging desires','oversharing','holding back','expressing vulnerability','rehearsing conversations','feeling déjà vu','sensing danger','adapting to change','seeking closure','embracing new routines','reshaping identity','grieving past versions of yourself','romanticizing life','savoring moments','cherishing memories','striving for purpose','nurturing curiosity','exploring possibilities','wandering aimlessly','cultivating patience','navigating uncertainty','repairing mistakes','creating new habits','breaking old habits','evolving','learning continuously','being human'];

const LS_KEY = "activity_pills_selected_v2";
const LS_OPEN = "activity_pills_open_v2";

let selected = new Set();
try {
  const raw = localStorage.getItem(LS_KEY);
  if (raw) {
    const arr = JSON.parse(raw);
    if (Array.isArray(arr)) selected = new Set(arr);
  }
} catch(e) {}

let openState = {};
try {
  const raw = localStorage.getItem(LS_OPEN);
  if (raw) openState = JSON.parse(raw) || {};
} catch(e) {}

const app = document.getElementById("app");
const q = document.getElementById("q");
const countEl = document.getElementById("count");
const toast = document.getElementById("toast");
const sfxToggleBtn = document.getElementById("sfxToggleBtn");
const musicToggleBtn = document.getElementById("musicToggleBtn");
const bgMusic = document.getElementById("bgMusic");
if (bgMusic) { bgMusic.volume = 0.22; }

function syncAudioButtons() {
  if (sfxToggleBtn) {
    sfxToggleBtn.setAttribute("aria-pressed", sfxEnabled ? "true" : "false");
    sfxToggleBtn.textContent = sfxEnabled ? "Sound FX: On" : "Sound FX: Off";
  }
  if (musicToggleBtn) {
    musicToggleBtn.setAttribute("aria-pressed", musicEnabled ? "true" : "false");
    musicToggleBtn.textContent = musicEnabled ? "Music: On" : "Music: Off";
  }
}

// restore saved states (sound fx defaults ON, music defaults OFF)
try {
  const p = localStorage.getItem(LS_SFX);
  if (p !== null) sfxEnabled = (p === "1");
  // Music intentionally defaults OFF on load.
} catch(e) {}

syncAudioButtons();

// Music stays OFF on page load (browser gesture rules + your preference).
// Hero video fallback: hide hint if the video actually loads
try {
  const vid = document.getElementById("davidVid");
  const fb = document.getElementById("heroFallback");
  if (vid && fb) {
    const hide = () => { fb.style.display = "none"; };
    const show = () => { fb.style.display = ""; };
    vid.addEventListener("canplay", hide);
    vid.addEventListener("playing", hide);
    vid.addEventListener("error", show);
    // If the browser already has enough data
    if (vid.readyState >= 2) hide();
  }
} catch(e) {}


function saveSelected() {
  try { localStorage.setItem(LS_KEY, JSON.stringify([...selected])); } catch(e) {}
}
function saveOpen() {
  try { localStorage.setItem(LS_OPEN, JSON.stringify(openState)); } catch(e) {}
}

function chunk(arr, size) {
  const out = [];
  for (let i = 0; i < arr.length; i += size) out.push(arr.slice(i, i + size));
  return out;
}

function showToast(msg) {
  toast.textContent = msg;
  toast.classList.add("show");
  clearTimeout(showToast._t);
  showToast._t = setTimeout(()=>toast.classList.remove("show"), 1200);
}

function normalize(s) {
  return (s || "").toLowerCase().trim();
}


// --- Guided section mode (25 segments + Next/Previous) ---
// We build 25 sections total: 24 slices of the big list + 1 dedicated "Stimming" section.
// Stimming section includes clinical / medical-ish terminology, and we remove any overlap from the main pool
// so nothing appears twice.

const STIM_TITLE = "Stimming";
const STIM_TERMS = [
  "stimming",
  "pacing",
  "self-stimulation",
  "self-stimulatory behavior",
  "self-stimulatory activity",
  "stereotypy",
  "stereotypic behavior",
  "stereotypic movements",
  "motor stereotypy",
  "vocal stereotypy",
  "stereotyped movements",
  "stereotyped and repetitive motor movements",
  "repetitive motor behaviors",
  "repetitive behaviors",
  "sensorimotor stimulation",
  "sensory seeking",
  "sensory avoidance",
  "sensory modulation",
  "sensory regulation",
  "sensory self-regulation",
  "sensory processing",
  "self-regulation",
  "self-soothing",
  "proprioceptive input seeking",
  "vestibular seeking",
  "tactile seeking",
  "auditory seeking",
  "visual seeking",
  "oral sensory seeking",
  "perseveration",
  "echolalia",
  "palilalia",
  "body-focused repetitive behavior",
  "bfrb",
  "trichotillomania",
  "excoriation disorder",
  "dermatillomania",
  "onychophagia",
  "onychotillomania",
  "morsicatio buccarum",
  "bruxism",
  "stereotypic movement disorder"
];

const TITLE_RULES = [
  { title: "Body & senses", keywords: ["breath","blink","swallow","chew","stretch","yawn","sleep","wake","sneeze","cough","shiver","sweat","hear","see","smell","touch"] },
  { title: "Hygiene & self-care", keywords: ["shower","brush teeth","floss","deodor","shave","comb","lotion","get dressed","undress","nails","exfol","moistur","sunscreen","bath"] },
  { title: "Home reset & chores", keywords: ["clean","vacuum","sweep","mop","laundry","fold","iron","trash","recycl","tidy","declutter","organiz","dish","counter","pantry"] },
  { title: "Food & kitchen", keywords: ["cook","bake","boil","fry","roast","chop","meal","prep","coffee","tea","pasta","soup","bread","cake","recipe","taste"] },
  { title: "Social & communication", keywords: ["talk","text","email","call","message","meet","party","host","friend","hug","handshake","listen","comfort","compliment","apolog","forgiv","debate"] },
  { title: "Emotions & relationships", keywords: ["feel","grief","celebrat","pride","relief","anxiety","joy","frustr","excite","miss","let go","boundar","relationship","dating","heartbreak"] },
  { title: "Creativity & art", keywords: ["draw","sketch","paint","sculpt","craft","knit","crochet","sew","quilt","wood","pottery","calligraphy","illustrat","design","collage","zine"] },
  { title: "Writing & storytelling", keywords: ["read","write","edit","proof","poetry","fiction","essay","script","story","worldbuild","journal","blog","newsletter","review"] },
  { title: "Music & performance", keywords: ["music","sing","humm","compose","improv","dance","act","karaoke","choreo","rehears","perform","podcast","record","mix"] },
  { title: "Outdoors & nature", keywords: ["hike","trail","camp","garden","plant","bird","stargaz","forest","lake","beach","waterfall","forag","mushroom","compost","wildlife"] },
  { title: "Sports & training", keywords: ["run","jog","sprint","swim","yoga","pilates","lift","boxing","martial","tennis","soccer","basketball","volley","climb","skate","ski"] },
  { title: "Digital & tech", keywords: ["internet","youtube","stream","scroll","discord","gaming","code","program","debug","website","ui/ux","app","api","database","wifi","firmware","ai","vr","ar"] },
  { title: "Work & productivity", keywords: ["work","meeting","cowork","present","project","schedule","time management","delegat","inventory","customer service","report","quality control","manufactur"] },
  { title: "Study & learning", keywords: ["study","test","class","lecture","textbook","notes","lab","experiment","hypothes","workshop","tutor","homework","learn"] },
  { title: "Health & appointments", keywords: ["medication","prescription","therapy","checkup","symptom","first aid","bandag","vitamin","massage","physical therapy","chiropr","appointment"] },
  { title: "Travel & exploring", keywords: ["travel","airport","flight","hotel","tour","luggage","passport","security","taxi","subway","map","sightsee","souvenir","café"] },
  { title: STIM_TITLE, keywords: ["stimm","stereotyp","sensory","self-sooth","echol","palil","bfrb","trich","excori","dermatill","brux","onych","morsicatio"] }
];

function scoreByKeywords(items, keywords) {
  let s = 0;
  for (const it of items) {
    const t = normalize(it);
    for (const kw of keywords) {
      if (t.includes(kw)) { s += 1; break; }
    }
  }
  return s;
}

function inferSegmentTitle(items) {
  let bestTitle = "Mixed";
  let bestScore = -1;
  for (const rule of TITLE_RULES) {
    if (rule.title === STIM_TITLE) continue;
    const sc = scoreByKeywords(items, rule.keywords);
    if (sc > bestScore) {
      bestScore = sc;
      bestTitle = rule.title;
    }
  }
  // If a segment is truly mixed, keep it honest.
  const ratio = items.length ? (bestScore / items.length) : 0;
  if (bestScore < 2 && ratio < 0.10) return "Mixed";
  return bestTitle;
}

function tokenizeForTitle(s) {
  return (s || "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, " ")
    .trim()
    .split(/\s+/)
    .filter(Boolean);
}

// Words that are too generic to help name a section
const TITLE_STOP = new Set([
  "a","an","and","or","the","to","of","in","on","for","with","at","by","from","into","over","under","about",
  "do","doing","done","make","making","made","take","taking","go","going","went","get","getting","got",
  "play","playing","practice","practicing","use","using","work","working","learn","learning","study","studying",
  "listen","listening","watch","watching","read","reading","write","writing","try","trying",
  "your","my","our","their","someone","something","things","thing",
  "day","days","night","nights","week","weeks","month","months","year","years",
  "new","old","good","better","best","little","big","small",
  "activity","activities"
]);

const TITLE_ACRONYMS = new Set(["ai","vr","ar","ui","ux","api","sql","cpu","gpu","ios","android","html","css","js","uxui"]);


function prettyBaseTitle(s) {
  return (s || "")
    .split(/\s+/)
    .filter(Boolean)
    .map(w => (w === "&" ? "&" : (w.charAt(0).toUpperCase() + w.slice(1))))
    .join(" ");
}

function niceToken(t) {
  if (!t) return "";
  if (TITLE_ACRONYMS.has(t)) return t.toUpperCase();
  if (/^\d+$/.test(t)) return t; // keep numbers inside tokens (e.g., 5k)
  return t.charAt(0).toUpperCase() + t.slice(1);
}

function signatureTokens(items, docFreq, N, take) {
  const tf = Object.create(null);
  for (const it of items) {
    for (const tok of tokenizeForTitle(it)) {
      if (tok.length < 3) continue;
      if (TITLE_STOP.has(tok)) continue;
      tf[tok] = (tf[tok] || 0) + 1;
    }
  }
  const scored = Object.keys(tf).map(tok => {
    const df = docFreq[tok] || 0;
    const idf = Math.log((N + 1) / (df + 1));
    return { tok, score: tf[tok] * idf };
  }).sort((a, b) => b.score - a.score);

  const out = [];
  for (const s of scored) {
    if (out.length >= take) break;
    out.push(s.tok);
  }
  return out;
}

function buildSegmentTitle(items, docFreq, N, take) {
  let base = inferSegmentTitle(items);
  if (base === "Mixed") base = "Mix & Match";
  base = prettyBaseTitle(base);

  const toks = signatureTokens(items, docFreq, N, take);
  const desc = toks.map(niceToken).filter(Boolean).slice(0, take).join(" & ");

  // If we couldn't find good signature tokens, just return the base.
  if (!desc) return base;
  return `${base} — ${desc}`;
}

function buildSegments(items) {
  const stimUnique = Array.from(new Set(STIM_TERMS.map(normalize))).filter(Boolean);
  const stimSet = new Set(stimUnique);

  // Remove any stim terms from the main pool so nothing is duplicated.
  const pool = [];
  for (const it of items) {
    const n = normalize(it);
    if (!n) continue;
    if (stimSet.has(n)) continue;
    pool.push(it);
  }

  const slicesWanted = 24; // +1 stimming section = 25 total
  const size = Math.max(1, Math.ceil(pool.length / slicesWanted));
  const slices = chunk(pool, size).slice(0, slicesWanted);
  while (slices.length < slicesWanted) slices.push([]);

  // Build document-frequency for naming (across non-stimming slices).
  const docFreq = Object.create(null);
  for (const seg of slices) {
    const seen = new Set();
    for (const it of seg) {
      for (const tok of tokenizeForTitle(it)) {
        if (tok.length < 3) continue;
        if (TITLE_STOP.has(tok)) continue;
        seen.add(tok);
      }
    }
    for (const tok of seen) docFreq[tok] = (docFreq[tok] || 0) + 1;
  }

  // Stimming is always Section 1 (as requested).
  const out = [{ title: STIM_TITLE, items: stimUnique }];

  // Generate unique, descriptive titles for every other section (no numeric suffixes).
  const used = new Set([STIM_TITLE]);
  for (let i = 0; i < slicesWanted; i++) {
    const segItems = slices[i];

    let take = 2;
    let title = buildSegmentTitle(segItems, docFreq, slicesWanted, take);
    while (used.has(title) && take < 5) {
      take += 1;
      title = buildSegmentTitle(segItems, docFreq, slicesWanted, take);
    }
    // Ultra-rare collision fallback: add one more distinct token word (still no numbers).
    if (used.has(title)) {
      const extra = signatureTokens(segItems, docFreq, slicesWanted, 6).slice(5, 6)[0];
      if (extra) title = `${title} — ${niceToken(extra)}`;
    }

    used.add(title);
    out.push({ title, items: segItems });
  }

  return out.slice(0, 25);
}


const SEGMENTS = buildSegments(ITEMS);
const TOTAL_SEGS = SEGMENTS.length;
const TOTAL_ITEMS = SEGMENTS.reduce((n, s) => n + (s.items ? s.items.length : 0), 0);

// Update placeholder count dynamically (so it stays true even if the list changes)
try { q.placeholder = `Search (e.g., breathe, cook, program) — ${TOTAL_ITEMS} items`; } catch(e) {}
const LS_SEGIDX = "vap_seg_idx";
const LS_GUIDED = "vap_guided";

let guidedMode = true;
let segIdx = 0;

try {
  const g = localStorage.getItem(LS_GUIDED);
  if (g !== null) guidedMode = (g === "1");
  const s = localStorage.getItem(LS_SEGIDX);
  if (s !== null) {
    const n = parseInt(s, 10);
    if (!Number.isNaN(n)) segIdx = Math.max(0, Math.min(TOTAL_SEGS - 1, n));
  }
} catch(e) {}

const modeToggleBtn = document.getElementById("modeToggleBtn");
const prevSegBtn = document.getElementById("prevSegBtn");
const nextSegBtn = document.getElementById("nextSegBtn");
const segLabel = document.getElementById("segLabel");

function setGuided(next) {
  guidedMode = !!next;
  try { localStorage.setItem(LS_GUIDED, guidedMode ? "1" : "0"); } catch(e) {}
  document.body.dataset.guided = guidedMode ? "true" : "false";
  if (modeToggleBtn) {
    modeToggleBtn.setAttribute("aria-pressed", guidedMode ? "true" : "false");
    modeToggleBtn.textContent = guidedMode ? "Guided: On" : "Guided: Off";
  }
  // When turning guided on, make sure current segment is open in openState
  if (guidedMode) {
    openState[`sec_${segIdx}`] = true;
    saveOpen();
  }
}

function setSegIdx(nextIdx) {
  segIdx = Math.max(0, Math.min(TOTAL_SEGS - 1, nextIdx));
  try { localStorage.setItem(LS_SEGIDX, String(segIdx)); } catch(e) {}
}

function syncStepper() {
  document.body.dataset.guided = guidedMode ? "true" : "false";
  const topic = (SEGMENTS[segIdx] && SEGMENTS[segIdx].title) || `Segment ${segIdx+1}`;
  if (segLabel) segLabel.textContent = `Section ${segIdx+1}/${TOTAL_SEGS}`;
  if (prevSegBtn) prevSegBtn.disabled = !guidedMode || segIdx <= 0;
  if (nextSegBtn) nextSegBtn.disabled = !guidedMode || segIdx >= TOTAL_SEGS - 1;
  if (modeToggleBtn) {
    modeToggleBtn.setAttribute("aria-pressed", guidedMode ? "true" : "false");
    modeToggleBtn.textContent = guidedMode ? "Guided: On" : "Guided: Off";
  }
}

setGuided(guidedMode);
syncStepper();

if (modeToggleBtn) {
  modeToggleBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    keepScrollStable(() => {
      setGuided(!guidedMode);
      syncStepper();
      render();
      playSfx();
    });
  });
}

if (prevSegBtn) {
  prevSegBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    keepScrollStable(() => {
      if (!guidedMode) return;
      setSegIdx(segIdx - 1);
      syncStepper();
      render();
    });
    try { prevSegBtn.focus({preventScroll:true}); } catch(e) { try { prevSegBtn.focus(); } catch(_) {} }
  });
}


if (nextSegBtn) {
  nextSegBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    keepScrollStable(() => {
      if (!guidedMode) return;
      if (segIdx >= TOTAL_SEGS - 1) return;
      setSegIdx(segIdx + 1);
      syncStepper();
      render();
    });
    try { nextSegBtn.focus({preventScroll:true}); } catch(e) { try { nextSegBtn.focus(); } catch(_) {} }
  });
}

function render() {
  const term = normalize(q.value);

  // Guided mode shows exactly one section at a time (the 10 fixed segments).
  // Search filters within the current (or each) segment, without changing the segment count.
  const segOrder = guidedMode ? [segIdx] : Array.from({length: TOTAL_SEGS}, (_, i) => i);

  app.innerHTML = "";
  let shown = 0;

  segOrder.forEach((seg) => {
    const base = (SEGMENTS[seg] && SEGMENTS[seg].items) || [];
    const g = term ? base.filter(x => normalize(x).includes(term)) : base.slice();

    // When browsing all sections and searching, hide empty sections for sanity.
    if (!guidedMode && term && g.length === 0) return;

    const key = `sec_${seg}`;

    const det = document.createElement("details");
    det.dataset.sec = String(seg);

    const shouldOpen = guidedMode ? true : ((key in openState) ? !!openState[key] : (seg === 0));
    det.open = shouldOpen;

    det.addEventListener("toggle", () => {
      openState[key] = det.open;
      saveOpen();
    });

    const sum = document.createElement("summary");

    const left = document.createElement("div");
    left.className = "summaryLeft";

    const title = document.createElement("div");
    title.className = "sectionTitle";
    const topic = (SEGMENTS[seg] && SEGMENTS[seg].title) || `Segment ${seg + 1}`;
    title.textContent = topic;

    const meta = document.createElement("div");
    meta.className = "sectionMeta";
    const secSelected = base.filter(x => selected.has(x)).length;
    meta.textContent = `${secSelected}/${base.length} selected`;

    left.appendChild(title);
    left.appendChild(meta);

    const right = document.createElement("div");
    right.className = "sectionMeta";
    right.textContent = term ? `${g.length} match` : `${base.length} items`;

    sum.appendChild(left);
    sum.appendChild(right);

    const pills = document.createElement("div");
    pills.className = "pills";

    g.forEach((label) => {
      const b = document.createElement("div");
      b.className = "pill";
      b.setAttribute("role", "button");
      b.setAttribute("tabindex", "0");
      const isSel = selected.has(label);
      b.setAttribute("aria-pressed", isSel ? "true" : "false");
      if (isSel) applyAccent(b, label);
      b.dataset.label = label;
      b.textContent = label;
      pills.appendChild(b);
      shown += 1;
    });

    det.appendChild(sum);
    det.appendChild(pills);

    // In Guided mode, put navigation AFTER the last option in the segment (better ergonomics).
    if (guidedMode) {
      const bottomNav = document.createElement("div");
      bottomNav.className = "bottomNav";

      const prev2 = document.createElement("button");
      prev2.className = "btn btnStep btnNav";
      prev2.type = "button";
      prev2.textContent = "◀ Previous";
      prev2.disabled = segIdx <= 0;

      const next2 = document.createElement("button");
      next2.className = "btn btnStep btnNav";
      next2.type = "button";
      next2.textContent = "Next ▶";
      next2.disabled = segIdx >= TOTAL_SEGS - 1;

      prev2.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        keepScrollStable(() => {
          if (!guidedMode || segIdx <= 0) return;
          setSegIdx(segIdx - 1);
          syncStepper();
          render();
        });
        const p = document.getElementById("prevSegBtn");
        try { p && p.focus({preventScroll:true}); } catch(e) { try { p && p.focus(); } catch(_) {} }
      });

      next2.addEventListener("click", (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        keepScrollStable(() => {
          if (!guidedMode || segIdx >= TOTAL_SEGS - 1) return;
          setSegIdx(segIdx + 1);
          syncStepper();
          render();
        });
        const n = document.getElementById("nextSegBtn");
        try { n && n.focus({preventScroll:true}); } catch(e) { try { n && n.focus(); } catch(_) {} }
      });

      bottomNav.appendChild(prev2);
      bottomNav.appendChild(next2);
      det.appendChild(bottomNav);
    }

    app.appendChild(det);
  });

  countEl.textContent = `${shown} shown • ${selected.size} selected`;
  syncStepper();
}

function updateSectionMetaFast() {
  const details = app.querySelectorAll("details");
  details.forEach(det => {
    const pills = det.querySelectorAll(".pill");
    let secSel = 0;
    pills.forEach(p => {
      if (p.getAttribute("aria-pressed") === "true") secSel++;
    });
    const meta = det.querySelector(".summaryLeft .sectionMeta");
    const sec = parseInt(det.dataset.sec || "0", 10);
    const baseLen = (SEGMENTS[sec] && SEGMENTS[sec].items) ? SEGMENTS[sec].items.length : pills.length;
    if (meta) meta.textContent = `${secSel}/${baseLen} selected`;
  });
  countEl.textContent = `${app.querySelectorAll(".pill").length} shown • ${selected.size} selected`;
}

// Gentle sound fx sound (WebAudio)
let audioCtx = null;

function playSfx() {
  if (!sfxEnabled) return;
  try {
    audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === "suspended") audioCtx.resume();

    const t = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filt = audioCtx.createBiquadFilter();

    // Slightly wider pitch variation + tiny detune so repeats feel less identical
    const base = 170 + Math.random() * 160; // 170–330 Hz (was 180–300)
    const drop = 0.68 + Math.random() * 0.18; // 0.68–0.86 (was 0.75)

    osc.type = "sine";
    osc.detune.setValueAtTime((Math.random() * 2 - 1) * 12, t); // ±12 cents
    osc.frequency.setValueAtTime(base, t);
    osc.frequency.exponentialRampToValueAtTime(Math.max(60, base * drop), t + 0.10);

    filt.type = "lowpass";
    filt.frequency.setValueAtTime(1200, t);
    filt.frequency.exponentialRampToValueAtTime(500, t + 0.12);

    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.exponentialRampToValueAtTime(0.30, t + 0.01); // ~3× louder (was 0.10)
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.14);

    osc.connect(filt);
    filt.connect(gain);
    gain.connect(audioCtx.destination);

    osc.start(t);
    osc.stop(t + 0.16);
  } catch(e) {}
}


// --- Tiny procedural synthwave loop (royalty-free because it's generated) ---
let musicNodes = null; // { master, delay, comp }
let musicTimer = null;
let nextNoteTime = 0;
let step16 = 0;

const TEMPO = 92;               // chill synthwave
const LOOKAHEAD_MS = 25;        // scheduler tick
const SCHEDULE_AHEAD = 0.12;    // seconds
const STEPS_PER_BEAT = 4;       // 16th notes

function ensureAudio() {
  audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") audioCtx.resume();
  return audioCtx;
}

function midiToHz(m) { return 440 * Math.pow(2, (m - 69) / 12); }

function env(g, t, a, d, s, r, peak=1.0) {
  // Simple ADSR-ish envelope on GainNode g.gain
  g.gain.cancelScheduledValues(t);
  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak), t + a);
  g.gain.exponentialRampToValueAtTime(Math.max(0.0002, peak * s), t + a + d);
  g.gain.exponentialRampToValueAtTime(0.0001, t + a + d + r);
}

function makeNoiseBuffer(ctx, seconds=1.0) {
  const len = Math.floor(ctx.sampleRate * seconds);
  const buf = ctx.createBuffer(1, len, ctx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i=0; i<len; i++) data[i] = (Math.random() * 2 - 1);
  return buf;
}

let noiseBuf = null;

function scheduleKick(t) {
  const ctx = ensureAudio();
  const o = ctx.createOscillator();
  const g = ctx.createGain();

  o.type = "sine";
  o.frequency.setValueAtTime(120, t);
  o.frequency.exponentialRampToValueAtTime(52, t + 0.09);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.55, t + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.12);

  o.connect(g);
  g.connect(musicNodes.master);

  o.start(t);
  o.stop(t + 0.14);
}

function scheduleSnare(t) {
  const ctx = ensureAudio();
  noiseBuf = noiseBuf || makeNoiseBuffer(ctx, 0.6);

  const src = ctx.createBufferSource();
  const bp = ctx.createBiquadFilter();
  const g = ctx.createGain();

  src.buffer = noiseBuf;

  bp.type = "bandpass";
  bp.frequency.setValueAtTime(1800, t);
  bp.Q.setValueAtTime(0.9, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.22, t + 0.003);
  g.gain.exponentialRampToValueAtTime(0.0001, t + 0.10);

  src.connect(bp);
  bp.connect(g);
  g.connect(musicNodes.master);

  src.start(t);
  src.stop(t + 0.11);
}

function scheduleHat(t, open=false) {
  const ctx = ensureAudio();
  noiseBuf = noiseBuf || makeNoiseBuffer(ctx, 0.6);

  const src = ctx.createBufferSource();
  const hp = ctx.createBiquadFilter();
  const g = ctx.createGain();

  src.buffer = noiseBuf;

  hp.type = "highpass";
  hp.frequency.setValueAtTime(6000, t);

  const peak = open ? 0.085 : 0.05;
  const dur  = open ? 0.09  : 0.035;

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(peak, t + 0.002);
  g.gain.exponentialRampToValueAtTime(0.0001, t + dur);

  src.connect(hp);
  hp.connect(g);
  g.connect(musicNodes.master);

  src.start(t);
  src.stop(t + dur + 0.01);
}

function scheduleBass(t, midi, len=0.20) {
  const ctx = ensureAudio();
  const o = ctx.createOscillator();
  const g = ctx.createGain();
  const f = ctx.createBiquadFilter();

  o.type = "sawtooth";
  o.frequency.setValueAtTime(midiToHz(midi), t);

  f.type = "lowpass";
  f.frequency.setValueAtTime(600, t);
  f.frequency.exponentialRampToValueAtTime(220, t + Math.max(0.05, len * 0.8));
  f.Q.setValueAtTime(1.1, t);

  g.gain.setValueAtTime(0.0001, t);
  g.gain.exponentialRampToValueAtTime(0.13, t + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, t + len);

  o.connect(f);
  f.connect(g);
  g.connect(musicNodes.master);

  o.start(t);
  o.stop(t + len + 0.02);
}

function schedulePad(t, rootMidi, len=1.6) {
  const ctx = ensureAudio();
  // simple minor 7-ish chord: root, m3, 5, b7
  const chord = [0, 3, 7, 10].map(x => rootMidi + x);
  chord.forEach((m, i) => {
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();

    o.type = "triangle";
    o.frequency.setValueAtTime(midiToHz(m) * (i === 0 ? 0.5 : 1.0), t); // fatten root
    o.detune.setValueAtTime((Math.random() * 2 - 1) * 9, t); // tiny drift

    f.type = "lowpass";
    f.frequency.setValueAtTime(950, t);
    f.Q.setValueAtTime(0.7, t);

    g.gain.setValueAtTime(0.0001, t);
    g.gain.exponentialRampToValueAtTime(0.032, t + 0.12);
    g.gain.exponentialRampToValueAtTime(0.0001, t + len);

    o.connect(f);
    f.connect(g);
    g.connect(musicNodes.delay);

    o.start(t);
    o.stop(t + len + 0.04);
  });
}

function initMusicGraph() {
  const ctx = ensureAudio();

  const master = ctx.createGain();
  master.gain.setValueAtTime(0.075, ctx.currentTime); // intentionally low

  const comp = ctx.createDynamicsCompressor();
  comp.threshold.setValueAtTime(-24, ctx.currentTime);
  comp.knee.setValueAtTime(18, ctx.currentTime);
  comp.ratio.setValueAtTime(4, ctx.currentTime);
  comp.attack.setValueAtTime(0.01, ctx.currentTime);
  comp.release.setValueAtTime(0.12, ctx.currentTime);

  const delay = ctx.createDelay();
  delay.delayTime.setValueAtTime(0.26, ctx.currentTime);

  const fb = ctx.createGain();
  fb.gain.setValueAtTime(0.22, ctx.currentTime);

  // routing: master -> comp -> destination
  // plus a little delay loop on the side
  master.connect(comp);
  comp.connect(ctx.destination);

  master.connect(delay);
  delay.connect(fb);
  fb.connect(delay);
  delay.connect(comp);

  musicNodes = { master, comp, delay, fb };
}

function scheduleStep(step, time) {
  // Drum grid (16ths)
  const beat = step % 16;

  // Kick on 1 and 3 (0 and 8)
  if (beat === 0 || beat === 8) scheduleKick(time);

  // Snare on 2 and 4 (4 and 12)
  if (beat === 4 || beat === 12) scheduleSnare(time);

  // Hats: 8ths, with a little open hat on the "and" of 4
  if (beat % 2 === 0) scheduleHat(time, false);
  if (beat === 14) scheduleHat(time, true);

  // Bass pattern (A minor-ish): A2, A2, G2, A2, C3, B2, G2, A2
  const bassSeq = [45,45,43,45,48,47,43,45]; // MIDI
  if (beat % 2 === 0) { // 8th notes
    const idx = (step/2) % bassSeq.length;
    scheduleBass(time, bassSeq[idx], 0.18);
  }

  // Pad: once per bar
  if (beat === 0) {
    const roots = [57, 55, 53, 55]; // A3, G3, F3, G3
    const bar = Math.floor(step / 16) % roots.length;
    schedulePad(time, roots[bar], 1.55);
  }
}

function scheduler() {
  const ctx = ensureAudio();
  while (nextNoteTime < ctx.currentTime + SCHEDULE_AHEAD) {
    scheduleStep(step16, nextNoteTime);

    const secondsPerBeat = 60.0 / TEMPO;
    nextNoteTime += secondsPerBeat / STEPS_PER_BEAT; // 16ths
    step16 = (step16 + 1) % 64; // 4 bars
  }
}

/* --- Background music: plays synthwave_loop.wav (file next to this HTML) --- */
let musicFadeRAF = null;
const MUSIC_VOL = 0.22;

function fadeMusic(toVol, ms = 420) {
  if (!bgMusic) return;
  if (musicFadeRAF) cancelAnimationFrame(musicFadeRAF);
  const from = bgMusic.volume;
  const start = performance.now();
  const dur = Math.max(50, ms);

  const tick = (now) => {
    const p = Math.min(1, (now - start) / dur);
    bgMusic.volume = from + (toVol - from) * p;
    if (p < 1) musicFadeRAF = requestAnimationFrame(tick);
  };
  musicFadeRAF = requestAnimationFrame(tick);
}

async function startMusic() {
  if (musicEnabled) return;
  musicEnabled = true;

  if (!bgMusic) return;

  try {
    bgMusic.loop = true;
    // Start at near-silent, then fade in (feels smoother + less startling)
    bgMusic.volume = 0.0001;

    const p = bgMusic.play();
    if (p && typeof p.then === "function") await p;

    fadeMusic(MUSIC_VOL, 520);
  } catch (e) {
    // If the browser blocks playback, revert state so the UI stays honest.
    musicEnabled = false;
    try { syncAudioButtons(); } catch(_) {}
    try { showToast("Music blocked — click again."); } catch(_) {}
  }
}

function stopMusic() {
  if (!musicEnabled) return;
  musicEnabled = false;

  if (!bgMusic) return;

  try {
    // Fade out, then pause.
    fadeMusic(0.0001, 260);
    setTimeout(() => {
      if (!musicEnabled) {
        try { bgMusic.pause(); } catch(_) {}
      }
    }, 290);
  } catch (e) {
    try { bgMusic.pause(); } catch(_) {}
  }
}

function setMusic(on) {
  if (on) startMusic();
  else stopMusic();
  try { localStorage.setItem(LS_MUSIC, on ? "1" : "0"); } catch(e) {}
}

function setSfx(on) {
  sfxEnabled = !!on;
  try { localStorage.setItem(LS_SFX, sfxEnabled ? "1" : "0"); } catch(e) {}
}


// --- Selection accent randomness (noticeable but still cozy) ---
const accentByLabel = new Map();

function pickAccentPair() {
  // A small curated palette of vapor-ish hues (degrees on the HSL hue wheel)
  const pairs = [
    [300, 190], // pink + cyan
    [320, 200], // magenta + aqua
    [340, 175], // hot pink + teal
    [280, 210], // purple + blue-cyan
    [25,  200], // peach + cyan
    [210, 320], // blue + magenta
    [160, 300], // mint + pink
    [45,  190], // gold + cyan
  ];
  const [h1, h2] = pairs[Math.floor(Math.random() * pairs.length)];
  const jitter = (h) => h + (Math.random() * 12 - 6); // ±6 degrees
  return { h: jitter(h1), h2: jitter(h2) };
}

function applyAccent(el, label) {
  const a = accentByLabel.get(label) || pickAccentPair();
  accentByLabel.set(label, a);
  el.style.setProperty("--h", a.h);
  el.style.setProperty("--h2", a.h2);
}

function clearAccent(el, label) {
  accentByLabel.delete(label);
  el.style.removeProperty("--h");
  el.style.removeProperty("--h2");
}

function toggleLabel(label, pillEl) {
  if (selected.has(label)) {
    selected.delete(label);
    pillEl.setAttribute("aria-pressed", "false");
    clearAccent(pillEl, label);
  } else {
    selected.add(label);
    pillEl.setAttribute("aria-pressed", "true");
    applyAccent(pillEl, label);
  }
  saveSelected();
  playSfx();
  updateSectionMetaFast();
}
app.addEventListener("click", (ev) => {
  const pill = ev.target.closest(".pill");
  if (!pill) return;
  ev.preventDefault();
  ev.stopPropagation();
  keepScrollStable(() => toggleLabel(pill.dataset.label, pill));
});

app.addEventListener("keydown", (ev) => {
  const pill = ev.target.closest(".pill");
  if (!pill) return;
  if (ev.key === "Enter" || ev.key === " ") {
    ev.preventDefault();
    keepScrollStable(() => toggleLabel(pill.dataset.label, pill));
  }
});

document.getElementById("copyBtn").addEventListener("click", async () => {
  const out = [...selected].sort((a,b)=>a.localeCompare(b));
  const text = out.join(", ");
  if (!text) {
    showToast("Nothing selected.");
    return;
  }
  try {
    await navigator.clipboard.writeText(text);
    showToast("Copied selections.");
  } catch (e) {
    const ta = document.createElement("textarea");
    ta.value = text;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    ta.remove();
    showToast("Copied selections.");
  }
});

document.getElementById("clearBtn").addEventListener("click", () => {
  selected.clear();
  accentByLabel.clear();
  saveSelected();
  app.querySelectorAll(".pill").forEach(p => {
    p.setAttribute("aria-pressed", "false");
    p.style.removeProperty("--h");
    p.style.removeProperty("--h2");
  });
  updateSectionMetaFast();
  showToast("Cleared.");
});

document.getElementById("expandBtn").addEventListener("click", () => {
  app.querySelectorAll("details").forEach((d) => {
    d.open = true;
    const sec = d.dataset.sec;
    if (sec !== undefined) openState[`sec_${sec}`] = true;
  });
  saveOpen();
});

document.getElementById("collapseBtn").addEventListener("click", () => {
  app.querySelectorAll("details").forEach((d) => {
    d.open = false;
    const sec = d.dataset.sec;
    if (sec !== undefined) openState[`sec_${sec}`] = false;
  });
  saveOpen();
});

let _t = null;
q.addEventListener("input", () => {
  clearTimeout(_t);
  _t = setTimeout(render, 80);
});


// --- Audio toggle button wiring ---
if (sfxToggleBtn) {
  sfxToggleBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    const next = !sfxEnabled;
    setSfx(next);
    syncAudioButtons();
    // Give a confirmation sound fx only when turning ON
    if (sfxEnabled) playSfx();
  });
}

if (musicToggleBtn) {
  musicToggleBtn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    const next = !musicEnabled;
    setMusic(next);
    syncAudioButtons();
    // Optional tactile feedback (respects sound fx toggle)
    playSfx();
  });
}


render();
</script>
</body>
</html>
